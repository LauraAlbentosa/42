typedef struct s_stack
{
    int num;
    int index;
    int cost;
    int    medium;
    int    cheapest;
    struct  s_stack *target_node;
    struct  s_stack *next;
    struct  s_stack *prev;
}  t_stack;

void    push_a(t_stack **stack_a, t_stack **stack_b)
{
    t_stack *first_b;

    if (!*stack_b)
        return;
    first_b = *stack_b;
    *stack_b = (*stack_b)->next;
    first_b->next = *stack_a;
    *stack_a = first_b;
    write(1, "pa\n", 3);
}

void    push_b(t_stack **stack_a, t_stack **stack_b)
{
    t_stack *first_b;

    if (!*stack_b)
        return;
    first_b = *stack_b;
    *stack_b = (*stack_b)->next;
    first_b->next = *stack_a;
    *stack_a = first_b;
    write(1, "pb\n", 3);
}

void    reverse_rotate(t_stack **stack)
{
    t_stack *current;
    t_stack *second_last;
    t_stack *last;

    current = *stack;

    while(current->next->next)
        current = current->next;

    second_last = current;
    last = current->next;

    second_last->next = NULL;
    last->next = *stack;
    *stack = last;
}

void    rra(t_stack **a)
{
    reverse_rotate(a);
    write(1, "rra\n", 4);
}
void    rrb(t_stack **b)
{
    reverse_rotate(b);
    write(1, "rrb\n", 4);
}
void    rrr(t_stack **a, t_stack **b)
{
    reverse_rotate(a);
    reverse_rotate(b);
    write(1, "rrr\n", 4);
}



void    swap_a(t_stack **stack)
{
    t_stack *first;
    t_stack *second;
    int len;
    
    len = stack_len(*stack);
    if (len < 2)
        return;
        
    first = *stack;
    second = first->next;
    first->next = second->next;
    second->next = first;
    *stack = second;
    write(1, "sa\n", 3);
}

void    swap_b(t_stack **stack)
{
    t_stack *first;
    t_stack *second;
    int len;
    
    len = stack_len(*stack);
    if (len < 2)
        return;
        
    first = *stack;
    second = first->next;
    first->next = second->next;
    second->next = first;
    *stack = second;
    write(1, "sb\n", 3);
}
void    rotate(t_stack **stack)
{
    t_stack *current;
    t_stack *first;

    first = *stack;
    current = *stack;
    
    while(current->next)
        current = current->next;

    current->next = first;
    *stack = first->next;
    first->next = NULL;
}

void    ra(t_stack **a)
{
    rotate(a);
    write(1, "ra\n", 3);
}

void    rb(t_stack **b)
{
    rotate(b);
    write(1, "rb\n", 3);
}

void    rr(t_stack **a, t_stack **b)
{
    rotate(a);
    rotate(b);
    write(1, "rr\n", 3);
}


void    display_error(t_stack **stack)
{
    free_stacks(stack);
    write(2, "Error\n", 6);
    exit(1);
}

void free_stacks(t_stack **stack)
{
    t_stack *temp;
    t_stack *current;
    if (!stack)
        return;
    current = *stack;
    while(current)
    {
        temp = current->next;
        current->num = 0;
        free(current);
        current = temp;
    }
    *stack = NULL;
}

int is_number(char  *str)
{
    if (!(*str == '+'|| *str == '-' || (*str >= '0' && *str <= '9')))
        return (1);
    if ((*str == '+'|| *str == '-' ) && !(str[1] >= '0' && str[1] <= '9'))
        return (1);
    while (*str)
    {
        if (!(*str >= '0' && *str <= '9'))
            return (1);
        str++;
    }
    return (0);
}

int duplicates(t_stack *stack, int n)
{
    if (!stack)
        return (0);
    while (stack)
    {
        if (stack->num == n)
            return (1);
        stack = stack->next;
    }
    return (0);
}

void	check_min(t_stack **a) 
{
	while ((*a)->num != find_min(*a)->num) 
	{
		if (find_min(*a)->medium) 
			ra(a);
		else
			rra(a);
	}
}


t_stack *find_last(t_stack *stack)
{
    if(!stack)
        return (NULL);
    while(stack->next)
        stack = stack->next;
    return (stack);
}

int stack_len(t_stack *stack)
{
    int i;

    if (!stack)
        return (0);
    i = 0;
    while(stack)
    {
        stack = stack->next;
        i++;
    }
    return(i);
}

void    node_to_top(t_stack **stack, t_stack *top, char stack_name)
{
    while (*stack != top)
    {
        if (stack_name == 'a')
        {
            if (top->medium)
                ra(stack);
            else
                rra(stack);
        }
        else if (stack_name == 'b')
        {
            if (top->medium)
                rb(stack);
            else
                rrb(stack);
        }
    }
}

t_stack *find_min(t_stack *stack)
{
    long    min;
    t_stack *min_node;
    
    if(!stack)
        return(NULL);
    min = LONG_MAX;
    while (stack)
    {
        if (stack->num < min)
        {
            min = stack->num;
            min_node = stack;  
        }
        stack = stack->next;
    }
    return(min_node);
}

t_stack *find_max(t_stack *stack)
{
    int max;
    t_stack *max_node;

    if (!stack)
        return (NULL);
    max = INT_MIN;
    while (stack)
    {
        if (stack->num > max)
        {
           max = stack->num;
           max_node = stack;
        }
        stack = stack->next;
    }
    return (max_node);

}



void    current_index(t_stack *stack)
{
    int i;
    int mid;

    i = 0;
    if (!stack)
        return;
    mid = stack_len(stack) / 2;
    while (stack)
    {
        stack->index = i;
        if (i <= mid)
            stack->medium = 1;
        else
            stack->medium = 0;
        stack = stack->next;
        i++;
    }

}

void set_target_a(t_stack *a, t_stack *b)
{
    t_stack *current_b;
    t_stack *target;
    int match;

    while(a)
    {
        match = INT_MIN;
        current_b = b;
        while(current_b)
        {
            if (current_b->num < a->num && current_b->num > match)
            {
                match = current_b->num;
                target = current_b;
            }
            current_b = current_b->next;
        }
        if (match == INT_MIN)
            a->target_node = find_max(b);
        else
            a->target_node = target;
        a = a->next;
    }
}

void    set_target_b(t_stack *a, t_stack *b)
{
    t_stack *current_a;
    t_stack *target;
    int match;

    while(b)
    {
        match = INT_MAX;
        current_a = a;
        while (current_a)
        {
            if (current_a->num > b->num && current_a->num < match)
            {
                match = current_a->num;
                target = current_a;
            }
            current_a = current_a->next;
        }
        if (match == INT_MAX)
            b->target_node = find_min(a);
        else
            b->target_node = target;
        b = b->next; 
    }
}

void cost(t_stack *a, t_stack *b)
{
    int len_a;
    int len_b;

    len_a = stack_len(a);
    len_b = stack_len(b);
    while (a)
    {
        a->cost = a->index;
        if (!(a->medium))
            a->cost = len_a - (a->index);
        if (a->target_node->medium)
            a->cost += a->target_node->index;
        else
            a->cost += len_b - (a->target_node->index);
        a = a->next;
    }
}

void    cheapest(t_stack *stack)
{
    int cheapest_value;
    t_stack *cheap_node;

    if (!stack)
        return;
    cheapest_value = INT_MAX;
    while(stack)
    {
        if (stack->cost < cheapest_value)
        {
            cheapest_value = stack->cost;
            cheap_node = stack;
        }
        stack = stack->next;
    }
    cheap_node->cheapest = 1;
}

t_stack *get_cheapest(t_stack *stack)
{
    if (!stack)
        return (NULL);
    while(stack)
    {
        if (stack->cheapest)
            return (stack);
        stack = stack->next;
    }
    return (NULL);
}



void    a_b(t_stack **a, t_stack **b)
{
    t_stack *cheapest_node;

    cheapest_node = get_cheapest(*a);
    if (cheapest_node->medium && cheapest_node->target_node->medium)
        rr(a, b);
    else if (!(cheapest_node->medium) && !(cheapest_node->target_node->medium))
        rrr(a, b);
    node_to_top(a, cheapest_node, 'a');
    node_to_top(b, cheapest_node, 'b');
    push_b(b, a);
}

void b_a(t_stack **a, t_stack **b) 
{
	node_to_top(a, (*b)->target_node, 'a'); 
	push_a(a, b); 
}



int    sorted(t_stack *stack)
{
    if (!stack)
        return(0);
    while (stack->next)
    {
        if (stack->num > stack->next->num)
            return(0);
        stack = stack->next;
        
    }
    return(1);
}

void    sort_three(t_stack **a)
{
    t_stack *max;

    max = find_max(*a);
    if(max == *a)
        ra(a);
    else if ((*a)->next == max)
        rra(a);
    if((*a)->num > (*a)->next->num)
        swap_a(a);
}

void    sort_stacks(t_stack **a, t_stack **b)
{
    int len_a;

    len_a = stack_len(*a);
    if (len_a - 1 > 3 && !sorted(*a))
        push_b(b, a);
    if (len_a - 1 > 3 && !sorted(*a))
        push_b(b, a);
    while(len_a - 1 > 3 && !sorted(*a))
    {
        init_a(*a, *b);
        a_b(a,b);
    }
    sort_three(a);
    while(*b)
    {
        init_b(*a,*b);
        b_a(a,b);
    }
    current_index(*a);
    check_min(a);
}
void    append_node(t_stack **stack, int n)
{
    t_stack *new;
    t_stack *last;

    if (!stack)
        return;
    new = malloc(sizeof(t_stack));
    if (!new)
        return;
    new->next = NULL;
    new->num = n;
    if(!(*stack))
    {
        *stack = new;
        new->prev = NULL;
    }
    else
    {
        last = find_last(*stack);
        last->next = new;
        new->prev = last;
    }
}

void    create_stack_a(t_stack **a, char **numbers)
{
    int n;
    int i;

    i = 0;
    while(numbers[i])
    {
        if(is_number(numbers[i]))
            display_error(a);
        n = ft_atoi(numbers[i]);
        if (n > INT_MAX || n < INT_MIN)
            display_error(a);
        if(duplicates(*a, n))
            display_error(a);
        append_node(a, n);
        i++;
    }
}

void    init_a(t_stack *a, t_stack *b)
{
    current_index(a);
    current_index(b);
    set_target_a(a, b);
    cost(a, b);
    cheapest(a);
}

void    init_b(t_stack *a, t_stack *b)
{
    current_index(a);
    current_index(b);
    set_target_b(a, b);
}

int main(int argc, char** argv)
{
    t_stack *a;
    t_stack *b;
    char    **numbers;

    a = NULL;
    b = NULL;
    if (argc == 1 || (argc == 2 && !argv[1][0]))
        return (1);
    else if (argc == 2)
        numbers = ft_split(argv[1], ' ');
    else 
        numbers = &argv[1];
    create_stack_a(&a, numbers);
    if (!sorted(a))
    {
        if (stack_len(a) == 2)
            swap_a(&a);
        else if (stack_len(a) == 3)
            sort_three(&a);
        else
            sort_stacks(&a, &b);
    }
    free_stacks(&a);
    return (0);
}